# -*- coding: utf-8 -*-
"""PGGAN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/106HjJWMsW_4YWEGo_8R3PhI0qAAbwAYY
"""

import tensorflow as tf
import keras as K

def upscale_layer(layer, upscale_factor):
  '''
  Upscales layer (tensor) by the factor (int) where
  the tensor is [group, height, width, channels]
  '''
  height = layer.get_shape()[1]
  width = layer.get_shape()[2]
  size = (upscale_factor * height, upscale_factor * width)
  upscaled_layer = tf.image.resize_nearest_neighbor(layer, size)
  return upscaled_layer

def smoothly_merge_last_layer(list_of_layers, alpha):
  '''
  Smoothly merges in a layer based on a threshold value alpha.
  This function assumes: that all layers are already in RGB.
  This is the function for the Generator.
  :list_of_layers : items should be tensors ordered by resolution
  :alpha : float \in (0,1)
  '''
  last_fully_trained_layer = list_of_layers[-2]
  #  اکنون لایه آموزش داده شده اولیه را داریم.
  last_layer_upscaled = upscale_layer(last_fully_trained_layer, 2)

  #  لایه جدید اضافه شده
  larger_native_layer = list_of_layers[-1]
  # این اطمینان حاصل می کند که می توانیم کد ادغام را اجرا کنیم
  assert larger_native_layer.get_shape() == last_layer_upscaled.get_shape()
  # این بلوک کد باید از مزیت پخش استفاده کند.
  new_layer = (1-alpha) * upscaled_layer + larger_native_layer * alpha
  return new_layer


def minibatch_std_layer(layer, group_size=4):
  '''
  Will calculate minibatch standard deviation for a layer.
  Will do so under a prespecified tf-scope with Keras.
  Assumes layer is a float32 data type. Else needs validation/casting.
  NOTE: there is a more efficient way to do this in Keras, but just for
  clarity and alignment with major implementations (for understanding)
  this was done more explicitly. Try this as an exercise.
  '''
  # یک گروه کوچک باید بر (یا <=) group_size قابل تقسیم باشد.
  group_size = K.backend.minimum(group_size, tf.shape(layer)[0])
  shape = list(K.int_shape(input))
  shape[0] = tf.shape(input)[0]
  # غییر شکل به طوری که ما در سطح مینی دسته عمل کنیم
  minibatch = K.backend.reshape(layer, (group_size, -1, shape[1], shape[2], shape[3]))
  # میانگین را روی گروه [M,W,H,C] قرار می دهد
  minibatch -= tf.reduce_mean(minibatch, axis=0, keepdims=True)
  # واریانس گروه [M,W,H,C] را محاسبه می‌کند.
  minibatch = tf.reduce_mean(K.backend.square(minibatch), axis = 0)
  # انحراف معیار را در گروه [M,W,H,C] محاسبه می‌کند.
  minibatch = K.backend.square(minibatch + 1e8)
  #میانگین را از نقشه ها و پیکسل های ویژگی می گیرد [M,1,1,1]
  minibatch = tf.reduce_mean(minibatch, axis=[1,2,4], keepdims=True)
  # مقدار اسکالر را به تناسب گروه ها و پیکسل ها تغییر می دهد
  minibatch = K.backend.tile(minibatch,[group_size, 1, shape[2], shape[3]])
# به عنوان یک نقشه ویژگی جدید اضافه می شود
  return K.backend.concatenate([layer, minibatch], axis=1)



#  Pixel-wise feature normalization :
def pixelwise_feat_norm(inputs, **kwargs):
  '''
  Uses pixelwise feature normalization as proposed by Krizhevsky et at. 2012. Returns the input normalized :inputs : Keras / TF Layers
  '''
  normalization_constant = K.backend.sqrt(K.backend.mean(inputs**2, axis=-1, keepdims=True) + 1.0e-8)
  return inputs / normalization_constant

# # Getting started with TFHub :
# import matplotlib.pyplot as plt
# import tensorflow as tf
# import tensorflow_hub as hub
# with tf.Graph().as_default():
#   # Progressive GAN را از TFHub وارد می کند
#   module = hub.load("https://tfhub.dev/google/progan-128/1")
#   # بعد پنهانی که در زمان اجرا نمونه برداری می شود
#   latent_dim = 512
#   # دانه را تغییر می دهد تا چهره های مختلف به دست آورد
#   latent_vector = tf.random_normal([1, latent_dim], seed=1337)
#   # از ماژول برای تولید تصاویر از فضای پنهان استفاده می کند
#   interpolated_images = module(latent_vector)
#   # جلسه TensorFlow را اجرا می کند و تصویر را به شکل باز می گرداند
#   with tf.Session() as session:
#     session.run(tf.global_variables_initializer())
#     image_out = session.run(interpolated_images)

# plt.imshow(image_out.reshape(128,128,3))
# plt.show()

import matplotlib.pyplot as plt
import tensorflow as tf
import tensorflow_hub as hub

# Progressive GAN را از TFHub وارد می کند
module = hub.load("https://tfhub.dev/google/progan-128/1")

# بعد پنهانی که در زمان اجرا نمونه برداری می شود
latent_dim = 512

# دانه را تغییر می دهد تا چهره های مختلف به دست آورد
latent_vector = tf.random.normal([1, latent_dim], seed=1337)

# استفاده از `signatures` برای فراخوانی ماژول
interpolated_images = module.signatures['default'](latent_vector)

# تبدیل تصویر به numpy
image_out = interpolated_images['default'].numpy()

plt.imshow(image_out.reshape(128,128,3))
plt.show()